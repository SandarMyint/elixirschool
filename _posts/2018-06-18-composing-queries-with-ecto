---
author: Sean Callan
author_link: https://github.com/doomspork
categories: post
date:   2018-06-20
layout: post
title:  Queries composition with Ecto
excerpt: >

---

Ecto is fantastic tool that affords us a great degree of flexibility.
In this blog post we'll look at how we can dynamically build our Ecto queries and sanitize our input data at the same time.

Let's plan to approach our composition in 3 steps:

- Create the base query we'll build upon
- Compose our query from input criteria
- Execute our final query

For our example we'll be working with everyone's favorite example project: a blog!
Before we begin take a peek at the schema we'll be building our code to interface with:

![image](https://user-images.githubusercontent.com/73386/41698787-7a4efb0e-74dd-11e8-970b-7fb8fe3fef14.png)

## Query base

To keep things clean we'll create a new module to contain the functionality for accessing the underlying schema data.
Let's move ahead with creating our module and addressing the first step above: the base query.

```elixir
defmodule Posts do
  import Ecto.Query

  defp base_query do
    (from p in Post)
  end
end  
```

Simple enough.
When `base_query/0` is called we'll create the initial query that will serve as the base for our criteria.
At this point our query is analogous to `SELECT * FROM posts`.

## Applying our criteria

Next we'll need to build upon `base_query/0` by applying our criteria, this is where the magic of our query composition shines!

There's a good chance when we apply our criteria it won't be simple comparisons.
Let's consider how we might look up a blog post by title.
It's unlikely we'll want to search by exact title, instead of `p.title == "Repo"` we want `p.title LIKE "%Repo%"`.

With that in mind it's easy to understand why the following is not only a bad idea, because it doesn't filter the criteria, but the resulting queries are basic `==` comparisons: 

```elixir
defp build_query(query, criteria) do
  expr = Enum.into(criteria, [])
  where(query, [], expr)
end
```

So how might we approach this problem instead?

Before we discuss the new approach let's decide on some business rules for Post look up, see them applied in our approach, and then walk through it.
For our example we will assume the following are always true:

- Searches for `title` are expected to be `LIKE "%title%"`
- Including `tags` requires _at least_ one.
- Simple comparison is available for `draft` and `id`
- All other values are discarded

Now that we know the rules around looking up a Post let's see them applied with query composition:

```elixir
defp build_query(query, criteria) do
  Enum.reduce(criteria, query, &compose_query/2)
end

defp compose_query(query, {"title", title}) do
  where(query, [p], fragment("? LIKE '%?%'", p.title, title))
end

defp compose_query(query, {"tags", tags}) do
  join(query, :left, [p], t in assoc(p, :tags), on: t.name in ^tags)
end

defp compose_query(query, {key, value}) when key in ~w(draft id) do
  where(query, [p], {String.to_atom(key), value})
end

defp compose_query(query, _unsupported_param) do
  query
end
```



## Bringing it all together

With `base_query/0` and `build_query/2` in place, let's define our public `all/1` function.
There's nothing special to running our query so we can setup our new function as a pipeline ending in `Repo.all/1`:

```elixir
def all(criteria) do
  base_query()
  |> build_query(criteria)
  |> Repo.all()
end
```

The result is public function, our module's API, that is concise and to a degree self documenting: "Get the base query, build the query with the criteria, and get all records".

If we bring it all together our resulting module should look something like:

```elixir
defmodule Posts do
  import Ecto.Query

  def all(criteria) do
    base_query()
    |> build_query(criteria)
    |> Repo.all()
  end

  defp base_query do
    (from p in Post)
  end

  defp build_query(criteria) do
    Enum.reduce(criteria, query, &compose_query/2)
  end

  defp compose_query(query, {"title", title}) do
    where(query, [p], fragment("? LIKE '%?%'", p.title, title))
  end

  defp compose_query(query, {"tags", tags}) do
    join(query, :left, [p], t in assoc(p, :tags), on: t.name in ^tags)
  end

  defp compose_query(query, {key, value}) when key in ~w(draft id) do
    where(query, [p], {String.to_atom(key), value})
  end

  defp compose_query(query, _unsupported_param) do
    query
  end
end
```

What do you think of this approach?  How are you composing our Ecto queries?  We'd love to hear your thoughts and suggestions!